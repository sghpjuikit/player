/*
 * Copyright (c) 2013, 2015, ControlsFX
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *     * Neither the name of ControlsFX, any associated website, nor the
 * names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL CONTROLSFX BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package gui.objects.grid;

import gui.objects.search.SearchAutoCancelable;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Stream;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.collections.transformation.SortedList;
import javafx.css.*;
import javafx.event.Event;
import javafx.scene.Node;
import javafx.scene.control.Control;
import javafx.scene.input.ScrollEvent;
import javafx.util.Callback;
import org.reactfx.EventStreams;
import util.access.V;
import util.access.fieldvalue.ObjectField;
import util.functional.Functors.Ƒ1;
import static gui.objects.grid.GridView.SelectionOn.KEY_PRESS;
import static gui.objects.grid.GridView.SelectionOn.MOUSE_CLICK;
import static java.util.Collections.unmodifiableList;
import static javafx.collections.FXCollections.observableArrayList;
import static javafx.scene.input.KeyEvent.KEY_PRESSED;
import static javafx.scene.input.KeyEvent.KEY_TYPED;
import static util.async.Async.runLater;
import static util.functional.Util.set;
import static util.functional.Util.stream;

/**
 * A GridView is a virtualized control for displaying items in a
 * visual, scrollable, grid-like fashion. In other words, whereas a ListView
 * shows one {@link javafx.scene.control.ListCell} per row, in a GridView there will be zero or more
 * {@link gui.objects.grid.GridCell} instances on a single row.
 * <p/>
 * This approach means that the number of GridCell instances
 * instantiated will be a significantly smaller number than the number of
 * items in the GridView items list, as only enough GridCells are created for
 * the visible area of the GridView. This helps to improve performance and
 * reduce memory consumption.
 * <p/>
 * Because each {@link gui.objects.grid.GridCell} extends from {@link javafx.scene.control.Cell}, the same approach
 * of cell factories that is taken in other UI controls is also taken in GridView.
 * This has two main benefits:
 * <ol>
 * <li>GridCells are created on demand and without user involvement,
 * <li>GridCells can be arbitrarily complex. A simple GridCell may just have
 * its {@link gui.objects.grid.GridCell#textProperty() text property} set, whereas a more complex
 * GridCell can have an arbitrarily complex scenegraph set inside its
 * {@link gui.objects.grid.GridCell#graphicProperty() graphic property} (as it accepts any Node).
 * </ol>
 *
 * @param <T> type of item wrapper to hold cached attributes of the item, can be the item type itself
 * @param <F> type of item displayed in a grid
 * @see GridCell
 */
public class GridView<T, F> extends Control {

	final Class<F> type;
	final ObservableList<T> itemsAll;
	final FilteredList<T> itemsFiltered;
	final SortedList<T> itemsSorted;
	final Ƒ1<T,F> filterByMapper;

	/*
	 * Predicate that filters the table list. Null predicate will match all
	 * items (same as always true predicate). The value reflects the filter
	 * generated by the user through the {@link #searchBox}. Changing the
	 * predicate programmatically is possible, however the searchBox will not
	 * react on the change, its effect will merely be overridden and when
	 * search box predicate changes, it will in turn override effect of a
	 * custom predicate.
	 */
	public final ObjectProperty<Predicate<? super T>> itemsPredicate;
	public final ObjectProperty<Comparator<? super T>> itemsComparator;

	public final V<T> selectedItem = new V<>(null);

	private boolean scrollFlag = true;

	public ObjectField<F,?> primaryFilterField;
	public final Search search = new Search();

	/** Creates a default, empty GridView control. */
	public GridView(Class<F> type) {
		this(type, null, null);
	}

	/** Creates a default, empty GridView control. */
	public GridView(Class<F> type, Ƒ1<T,F> filterByMapper) {
		this(type, filterByMapper, null);
	}

	/** Convenience constructor. Creates an empty GridView with specified sizes. */
	public GridView(Class<F> type, Ƒ1<T,F> filterByMapper, double cellWidth, double cellHeight, double vGap, double hGap) {
		this(type, filterByMapper, null);
		setCellWidth(cellWidth);
		setCellHeight(cellHeight);
		setHorizontalCellSpacing(hGap);
		setVerticalCellSpacing(vGap);
	}

	/** Convenience constructor. Creates a default GridView with the provided items. */
	@SuppressWarnings("unchecked")
	public GridView(Class<F> type, Ƒ1<T,F> filterByMapper, ObservableList<T> backingList) {
		this.type = type;
		this.filterByMapper = filterByMapper==null ? x -> (F) x : filterByMapper;

		itemsAll = backingList==null ? observableArrayList() : backingList;
		itemsFiltered = new FilteredList<>(itemsAll);
		itemsSorted = new SortedList<>(itemsFiltered);

		itemsPredicate = itemsFiltered.predicateProperty();
		itemsComparator = itemsSorted.comparatorProperty();

		getStyleClass().add(DEFAULT_STYLE_CLASS);

		// Decrease scrolling speed
		// The default scrolling speed is simply too much. On my system its more than a full
		// vertical 'view' which is very confusing as user loses any indication of scrolling amount.
		// impl: consume scroll events and re-fire with smaller vertical values
		double factor = 1/3d;
		addEventFilter(ScrollEvent.ANY, e -> {
			if (scrollFlag) {
				Event ne = new ScrollEvent(
						e.getEventType(), e.getX(), e.getY(), e.getScreenX(), e.getScreenY(),
						e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(), e.isDirect(),
						e.isInertia(), e.getDeltaX(), e.getDeltaY()*factor, e.getTextDeltaX(), e.getTextDeltaY()*factor,
						e.getTextDeltaXUnits(), e.getTextDeltaX(), e.getTextDeltaYUnits(), e.getTextDeltaY()*factor,
						e.getTouchCount(), e.getPickResult()
				);
				e.consume();
				scrollFlag = false;
				runLater(() -> {
					if (e.getTarget() instanceof Node) {
						((Node) e.getTarget()).fireEvent(ne);
					}
					scrollFlag = true;
				});
			}
		});

		// search
		addEventHandler(KEY_TYPED, search::onKeyTyped);
		addEventFilter(KEY_PRESSED, search::onKeyPressed);
		addEventFilter(KEY_PRESSED, search::onEscPressHide);
		addEventFilter(Event.ANY, e -> {
			if (search.isActive())
				search.updateSearchStyles();
		});
		EventStreams.changesOf(getItemsShown()).subscribe(c -> {
			if (search.isActive())
				search.updateSearchStyles();
		});
		setOnScroll(Event::consume);
	}

	@Override
	protected GViewSkin<T,F> createDefaultSkin() {
		return new GViewSkin<>(this);
	}

	@SuppressWarnings("unchecked")
	public GViewSkin<T,F> implGetSkin() {
		return (GViewSkin) getSkin();
	}

	public ObservableList<T> getItemsRaw() {
		return itemsAll;
	}

	public ObservableList<T> getItemsShown() {
		return itemsSorted;
	}

	public Stream<GridCell<T,F>> getCellsShown() {
		return implGetSkin().getCells();
	}

	/**
	 * Contains {@link gui.objects.grid.GridView.SelectionOn} constants, signaling when should the selection change.
	 * By default, contains {@link SelectionOn#MOUSE_CLICK} and {@link SelectionOn#KEY_PRESS}.
	 * <p/>
	 * Removing all elements from this sets will cause this grid ignore selection
	 */
	public final Set<SelectionOn> selectOn = set(MOUSE_CLICK, KEY_PRESS);

	/**
	 * Returns selected items.
	 * <p/>
	 * The stream is intended for immediate consumption because it may be backed by an observable.
	 */
	public Stream<T> getSelectedItems() {
		return selectedItem.get()==null ? Stream.empty() : Stream.of(selectedItem.get());
	}

	/**
	 * Returns selected items or all if none selected.
	 */
	public Stream<T> getSelectedOrAllItems() {
		return selectedItem.get()==null ? getItemsShown().stream() : Stream.of(selectedItem.get());
	}

	/**
	 * Returns selected items or all if none selected and asked
	 * <p/>
	 * The stream is intended for immediate consumption because it may be backed by an observable.
	 *
	 * @param orAll whether all items should be returned when no item is selected
	 */
	public Stream<T> getSelectedOrAllItems(boolean orAll) {
		return orAll ? getSelectedOrAllItems() : getSelectedItems();
	}

	/**
	 * Property for specifying how much spacing there is between each cell
	 * in a row (i.e. how much horizontal spacing there is).
	 */
	public final DoubleProperty horizontalCellSpacingProperty() {
		if (horizontalCellSpacing==null) {
			horizontalCellSpacing = new StyleableDoubleProperty(12) {
				@Override
				public CssMetaData<GridView<?,?>,Number> getCssMetaData() {
					return GridView.StyleableProperties.HORIZONTAL_CELL_SPACING;
				}

				@Override
				public Object getBean() {
					return GridView.this;
				}

				@Override
				public String getName() {
					return "horizontalCellSpacing";
				}
			};
		}
		return horizontalCellSpacing;
	}

	private DoubleProperty horizontalCellSpacing;

	/**
	 * Sets the amount of horizontal spacing there should be between cells in
	 * the same row.
	 *
	 * @param value The amount of spacing to use.
	 */
	public final void setHorizontalCellSpacing(double value) {
		horizontalCellSpacingProperty().set(value);
	}

	/**
	 * Returns the amount of horizontal spacing there is between cells in
	 * the same row.
	 */
	public final double getHorizontalCellSpacing() {
		return horizontalCellSpacing==null ? 12.0 : horizontalCellSpacing.get();
	}

	/**
	 * Property for specifying how much spacing there is between each cell
	 * in a column (i.e. how much vertical spacing there is).
	 */
	private DoubleProperty verticalCellSpacing;

	public final DoubleProperty verticalCellSpacingProperty() {
		if (verticalCellSpacing==null) {
			verticalCellSpacing = new StyleableDoubleProperty(12) {
				@Override
				public CssMetaData<GridView<?,?>,Number> getCssMetaData() {
					return GridView.StyleableProperties.VERTICAL_CELL_SPACING;
				}

				@Override
				public Object getBean() {
					return GridView.this;
				}

				@Override
				public String getName() {
					return "verticalCellSpacing";
				}
			};
		}
		return verticalCellSpacing;
	}

	/**
	 * Sets the amount of vertical spacing there should be between cells in
	 * the same column.
	 *
	 * @param value The amount of spacing to use.
	 */
	public final void setVerticalCellSpacing(double value) {
		verticalCellSpacingProperty().set(value);
	}

	/**
	 * Returns the amount of vertical spacing there is between cells in
	 * the same column.
	 */
	public final double getVerticalCellSpacing() {
		return verticalCellSpacing==null ? 12.0 : verticalCellSpacing.get();
	}

	/**
	 * Property representing the width that all cells should be.
	 */
	public final DoubleProperty cellWidthProperty() {
		if (cellWidth==null) {
			cellWidth = new StyleableDoubleProperty(64) {
				@Override
				public CssMetaData<GridView<?,?>,Number> getCssMetaData() {
					return GridView.StyleableProperties.CELL_WIDTH;
				}

				@Override
				public Object getBean() {
					return GridView.this;
				}

				@Override
				public String getName() {
					return "cellWidth";
				}
			};
		}
		return cellWidth;
	}

	private DoubleProperty cellWidth;

	/**
	 * Sets the width that all cells should be.
	 */
	public final void setCellWidth(double value) {
		cellWidthProperty().set(value);
	}

	/**
	 * Returns the width that all cells should be.
	 */
	public final double getCellWidth() {
		return cellWidth==null ? 64.0 : cellWidth.get();
	}

	/**
	 * Property representing the height that all cells should be.
	 */
	public final DoubleProperty cellHeightProperty() {
		if (cellHeight==null) {
			cellHeight = new StyleableDoubleProperty(64) {
				@Override
				public CssMetaData<GridView<?,?>,Number> getCssMetaData() {
					return GridView.StyleableProperties.CELL_HEIGHT;
				}

				@Override
				public Object getBean() {
					return GridView.this;
				}

				@Override
				public String getName() {
					return "cellHeight";
				}
			};
		}
		return cellHeight;
	}

	private DoubleProperty cellHeight;

	/**
	 * Sets the height that all cells should be.
	 */
	public final void setCellHeight(double value) {
		cellHeightProperty().set(value);
	}

	/**
	 * Returns the height that all cells should be.
	 */
	public final double getCellHeight() {
		return cellHeight==null ? 64.0 : cellHeight.get();
	}

	public void setCellSize(double cellWidth, double cellHeight) {
		setCellWidth(cellWidth);
		setCellHeight(cellHeight);
	}

	private ObjectProperty<Callback<GridView<T,F>,GridCell<T,F>>> cellFactory = new SimpleObjectProperty<>(this, "cellFactory");

	/**
	 * Property representing the cell factory that is currently set in this
	 * GridView, or null if no cell factory has been set (in which case the
	 * default cell factory provided by the GridView skin will be used). The cell
	 * factory is used for instantiating enough GridCell instances for the
	 * visible area of the GridView. Refer to the GridView class documentation
	 * for more information and examples.
	 */
	public final ObjectProperty<Callback<GridView<T,F>,GridCell<T,F>>> cellFactoryProperty() {
		return cellFactory;
	}

	/**
	 * Sets the cell factory to use to create {@link GridCell} instances to
	 * show in the GridView.
	 */
	public final void setCellFactory(Callback<GridView<T,F>,GridCell<T,F>> value) {
		cellFactory.set(value);
	}

	/**
	 * Returns the cell factory that will be used to create {@link GridCell}
	 * instances to show in the GridView.
	 */
	public final Callback<GridView<T,F>,GridCell<T,F>> getCellFactory() {
		return cellFactory.get();
	}

	private static final String DEFAULT_STYLE_CLASS = "grid-view";

	private interface StyleableProperties {
		CssMetaData<GridView<?,?>,Number> HORIZONTAL_CELL_SPACING =
				new CssMetaData<>("-fx-horizontal-cell-spacing", StyleConverter.getSizeConverter(), 12d) {

					@Override
					public Double getInitialValue(GridView<?,?> node) {
						return node.getHorizontalCellSpacing();
					}

					@Override
					public boolean isSettable(GridView<?,?> n) {
						return n.horizontalCellSpacing==null || !n.horizontalCellSpacing.isBound();
					}

					@Override
					@SuppressWarnings("unchecked")
					public StyleableProperty<Number> getStyleableProperty(GridView<?,?> n) {
						return (StyleableProperty<Number>) n.horizontalCellSpacingProperty();
					}
				};

		CssMetaData<GridView<?,?>,Number> VERTICAL_CELL_SPACING =
				new CssMetaData<>("-fx-vertical-cell-spacing", StyleConverter.getSizeConverter(), 12d) {

					@Override
					public Double getInitialValue(GridView<?,?> node) {
						return node.getVerticalCellSpacing();
					}

					@Override
					public boolean isSettable(GridView<?,?> n) {
						return n.verticalCellSpacing==null || !n.verticalCellSpacing.isBound();
					}

					@Override
					@SuppressWarnings("unchecked")
					public StyleableProperty<Number> getStyleableProperty(GridView<?,?> n) {
						return (StyleableProperty<Number>) n.verticalCellSpacingProperty();
					}
				};

		CssMetaData<GridView<?,?>,Number> CELL_WIDTH =
				new CssMetaData<>("-fx-cell-width", StyleConverter.getSizeConverter(), 64d) {

					@Override
					public Double getInitialValue(GridView<?,?> node) {
						return node.getCellWidth();
					}

					@Override
					public boolean isSettable(GridView<?,?> n) {
						return n.cellWidth==null || !n.cellWidth.isBound();
					}

					@Override
					@SuppressWarnings("unchecked")
					public StyleableProperty<Number> getStyleableProperty(GridView<?,?> n) {
						return (StyleableProperty<Number>) n.cellWidthProperty();
					}
				};

		CssMetaData<GridView<?,?>,Number> CELL_HEIGHT =
				new CssMetaData<>("-fx-cell-height", StyleConverter.getSizeConverter(), 64d) {

					@Override
					public Double getInitialValue(GridView<?,?> node) {
						return node.getCellHeight();
					}

					@Override
					public boolean isSettable(GridView<?,?> n) {
						return n.cellHeight==null || !n.cellHeight.isBound();
					}

					@Override
					@SuppressWarnings("unchecked")
					public StyleableProperty<Number> getStyleableProperty(GridView<?,?> n) {
						return (StyleableProperty<Number>) n.cellHeightProperty();
					}
				};

		List<CssMetaData<? extends Styleable,?>> STYLEABLES = unmodifiableList(stream(Control.getClassCssMetaData())
				.append(HORIZONTAL_CELL_SPACING, VERTICAL_CELL_SPACING, CELL_WIDTH, CELL_HEIGHT)
				.toList());
	}

	/**
	 * @return The CssMetaData associated with this class, which may include the CssMetaData of its super classes.
	 */
	public static List<CssMetaData<? extends Styleable,?>> getClassCssMetaData() {
		return StyleableProperties.STYLEABLES;
	}

	@Override
	public List<CssMetaData<? extends Styleable,?>> getControlCssMetaData() {
		return getClassCssMetaData();
	}

	/** Strategy for cell selection behavior. */
	public enum SelectionOn {
		MOUSE_HOVER, MOUSE_CLICK, KEY_PRESS
	}

	/** Predefined cell sizes. */
	public enum CellSize {
		SMALL(80),
		NORMAL(160),
		LARGE(240),
		VERY_LARGE(400),
		GIANT(600),
		EXTREME(800);

		public final double width;

		CellSize(double width) {
			this.width = width;
		}
	}

	class Search extends SearchAutoCancelable {
		@Override
		public void onSearch(String s) {
			for (int i = 0; i<getItemsShown().size(); i++) {
				String item = filterByMapper.apply(getItemsShown().get(i)).toString();
				if (matches(item, searchQuery.get())) {
					implGetSkin().select(i);
					updateSearchStyles();
					break;
				}
			}
		}

		@Override
		public void cancel() {
			super.cancel();
			updateSearchStyleRowsNoReset();
		}

		void updateSearchStyles() {
			if (isCancelable) searchAutoCanceller.start(cancelActivityDelay);
			updateSearchStyleRowsNoReset();
		}

		void updateSearchStyleRowsNoReset() {
			boolean searchOn = isActive();
			getCellsShown().forEach(cell -> {
				T t = cell.getItem();
				String item = t==null ? null : filterByMapper.apply(t).toString();
				boolean isMatch = item!=null && matches(item, searchQuery.get());
				cell.pseudoClassStateChanged(PC_SEARCH_MATCH, searchOn && isMatch);
				cell.pseudoClassStateChanged(PC_SEARCH_MATCH_NOT, searchOn && !isMatch);
			});
		}
	}
}