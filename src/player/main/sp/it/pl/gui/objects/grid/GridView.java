/*
 * Loosely based on ControlsFX:
 *
 * Copyright (c) 2013, ControlsFX
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *     * Neither the name of ControlsFX, any associated website, nor the
 * names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL CONTROLSFX BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package sp.it.pl.gui.objects.grid;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;
import java.util.stream.Stream;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.ObservableList;
import javafx.collections.ObservableSet;
import javafx.collections.transformation.FilteredList;
import javafx.collections.transformation.SortedList;
import javafx.css.CssMetaData;
import javafx.css.SimpleStyleableDoubleProperty;
import javafx.css.StyleConverter;
import javafx.css.Styleable;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableProperty;
import javafx.event.Event;
import javafx.scene.control.Control;
import javafx.util.Callback;
import org.jetbrains.annotations.Nullable;
import sp.it.pl.gui.objects.search.SearchAutoCancelable;
import sp.it.util.access.V;
import sp.it.util.access.fieldvalue.ObjectField;
import sp.it.util.access.fieldvalue.StringGetter;
import sp.it.util.functional.Functors.F1;
import static java.util.stream.Collectors.collectingAndThen;
import static java.util.stream.Collectors.toList;
import static javafx.collections.FXCollections.observableArrayList;
import static javafx.collections.FXCollections.observableSet;
import static sp.it.pl.gui.objects.grid.GridView.SelectionOn.KEY_PRESS;
import static sp.it.pl.gui.objects.grid.GridView.SelectionOn.MOUSE_CLICK;
import static sp.it.util.functional.Util.stream;
import static sp.it.util.functional.UtilKt.runnable;
import static sp.it.util.reactive.UtilKt.onChange;

/**
 * A GridView is an 2D virtualized control for displaying items in a 2D grid. It offers similar set of features as
 * {@link sp.it.pl.gui.objects.table.FilteredTable}, namely sorting, searching and filtering.
 * <p/>
 * This container is virtualized - the number of {@link sp.it.pl.gui.objects.grid.GridCell} instances depends on the number of
 * items displayed, not total. This helps to improve performance and reduce memory consumption.
 *
 * @param <T> type of item wrapper to hold cached attributes of the item, can be the item type itself
 * @param <F> type of item displayed in a grid
 * @see GridCell
 */
public class GridView<T, F> extends Control {

	final Class<F> type;
	final ObservableList<T> itemsAll;
	final FilteredList<T> itemsFiltered;
	final SortedList<T> itemsSorted;
	final F1<T,F> filterByMapper;

	/*
	 * Predicate that filters the table list. Null predicate will match all
	 * items (same as always true predicate). The value reflects the filter
	 * generated by the user through the {@link #searchBox}. Changing the
	 * predicate programmatically is possible, however the searchBox will not
	 * react on the change, its effect will merely be overridden and when
	 * search box predicate changes, it will in turn override effect of a
	 * custom predicate.
	 */
	public final ObjectProperty<Predicate<? super T>> itemsPredicate;
	public final ObjectProperty<Comparator<? super T>> itemsComparator;

	public final V<@Nullable T> selectedItem = new V<>(null);

	/** Initial filter criteria for the filter, used when filter is opened or additional filter added */
	public ObjectField<F,?> primaryFilterField;
	public final Search search = new Search();

	/** Creates a default, empty GridView control. */
	public GridView(Class<F> type) {
		this(type, null, null);
	}

	/** Creates a default, empty GridView control. */
	public GridView(Class<F> type, F1<T,F> filterByMapper) {
		this(type, filterByMapper, null);
	}

	/** Convenience constructor. Creates an empty GridView with specified sizes. */
	public GridView(Class<F> type, F1<T,F> filterByMapper, double cellWidth, double cellHeight, double vGap, double hGap) {
		this(type, filterByMapper, null);
		this.cellWidth.setValue(cellWidth);
		this.cellHeight.setValue(cellHeight);
		this.horizontalCellSpacing.setValue(hGap);
		this.verticalCellSpacing.setValue(vGap);
	}

	/** Convenience constructor. Creates a default GridView with the provided items. */
	@SuppressWarnings("unchecked")
	public GridView(Class<F> type, F1<T,F> filterByMapper, ObservableList<T> backingList) {
		this.type = type;
		this.filterByMapper = filterByMapper==null ? x -> (F) x : filterByMapper;

		itemsAll = backingList==null ? observableArrayList() : backingList;
		itemsFiltered = new FilteredList<>(itemsAll);
		itemsSorted = new SortedList<>(itemsFiltered);

		itemsPredicate = itemsFiltered.predicateProperty();
		itemsComparator = itemsSorted.comparatorProperty();

		// search
		search.installOn(this);
		addEventFilter(Event.ANY, e -> {
			if (search.isActive())
				search.updateSearchStyles();
		});
		onChange(getItemsShown(), runnable(() -> {
			if (search.isActive())
				search.updateSearchStyles();
		}));
		setOnScroll(Event::consume);

		getStyleClass().add(STYLE_CLASS);
	}

	@Override
	protected GridViewSkin<T,F> createDefaultSkin() {
		return new GridViewSkin<>(this);
	}

	@SuppressWarnings("unchecked")
	public GridViewSkin<T,F> implGetSkin() {
		return (GridViewSkin) getSkin();
	}

	public ObservableList<T> getItemsRaw() {
		return itemsAll;
	}

	public ObservableList<T> getItemsShown() {
		return itemsSorted;
	}

	protected Stream<GridCell<T,F>> getCellsAll() {
		return implGetSkin().getCellsAll();
	}

	public Stream<GridCell<T,F>> getCellsShown() {
		return implGetSkin().getCells();
	}

	/**
	 * Contains {@link sp.it.pl.gui.objects.grid.GridView.SelectionOn} constants, signaling when should the selection change.
	 * By default, contains {@link SelectionOn#MOUSE_CLICK} and {@link SelectionOn#KEY_PRESS}.
	 * <p/>
	 * Removing all elements from this sets will cause this grid ignore selection
	 */
	public final ObservableSet<SelectionOn> selectOn = observableSet(MOUSE_CLICK, KEY_PRESS);

	/**
	 * Returns selected items.
	 * <p/>
	 * The stream is intended for immediate consumption because it may be backed by an observable.
	 */
	public Stream<T> getSelectedItems() {
		return selectedItem.get()==null ? Stream.empty() : Stream.of(selectedItem.get());
	}

	/**
	 * Returns selected items or all if none selected.
	 */
	public Stream<T> getSelectedOrAllItems() {
		return selectedItem.get()==null ? getItemsShown().stream() : Stream.of(selectedItem.get());
	}

	/**
	 * Returns selected items or all if none selected and asked
	 * <p/>
	 * The stream is intended for immediate consumption because it may be backed by an observable.
	 *
	 * @param orAll whether all items should be returned when no item is selected
	 */
	public Stream<T> getSelectedOrAllItems(boolean orAll) {
		return orAll ? getSelectedOrAllItems() : getSelectedItems();
	}

	public StyleableDoubleProperty horizontalCellSpacing = new SimpleStyleableDoubleProperty(GridView.StyleableProperties.HORIZONTAL_CELL_SPACING, GridView.this, "horizontalCellSpacing", 12.0);
	public StyleableDoubleProperty verticalCellSpacing = new SimpleStyleableDoubleProperty(GridView.StyleableProperties.HORIZONTAL_CELL_SPACING, GridView.this, "verticalCellSpacing", 12.0);
	public StyleableDoubleProperty cellWidth = new SimpleStyleableDoubleProperty(GridView.StyleableProperties.CELL_WIDTH, GridView.this, "cellWidth", 64.0);
	public StyleableDoubleProperty cellHeight = new SimpleStyleableDoubleProperty(GridView.StyleableProperties.CELL_HEIGHT, GridView.this, "cellHeight", 64.0);
	public V<CellGap> cellGap = new V<>(CellGap.RELATIVE);

	/**
	 * Property representing the cell factory that is currently set in this
	 * GridView, or null if no cell factory has been set (in which case the
	 * default cell factory provided by the GridView skin will be used). The cell
	 * factory is used for instantiating enough GridCell instances for the
	 * visible area of the GridView. Refer to the GridView class documentation
	 * for more information and examples.
	 */
	public ObjectProperty<Callback<GridView<T,F>,GridCell<T,F>>> cellFactory = new SimpleObjectProperty<>(this, "cellFactory");

	public static final String STYLE_CLASS = "grid-view";

	private interface StyleableProperties {
		CssMetaData<GridView<?,?>,Number> HORIZONTAL_CELL_SPACING =
				new CssMetaData<>("-fx-horizontal-cell-spacing", StyleConverter.getSizeConverter(), 12d) {

					@Override
					public Double getInitialValue(GridView<?,?> node) {
						return node.horizontalCellSpacing.getValue();
					}

					@Override
					public boolean isSettable(GridView<?,?> n) {
						return n.horizontalCellSpacing==null || !n.horizontalCellSpacing.isBound();
					}

					@Override
					public StyleableProperty<Number> getStyleableProperty(GridView<?,?> n) {
						return n.horizontalCellSpacing;
					}
				};

		CssMetaData<GridView<?,?>,Number> VERTICAL_CELL_SPACING =
				new CssMetaData<>("-fx-vertical-cell-spacing", StyleConverter.getSizeConverter(), 12d) {

					@Override
					public Double getInitialValue(GridView<?,?> node) {
						return node.verticalCellSpacing.getValue();
					}

					@Override
					public boolean isSettable(GridView<?,?> n) {
						return n.verticalCellSpacing==null || !n.verticalCellSpacing.isBound();
					}

					@Override
					public StyleableProperty<Number> getStyleableProperty(GridView<?,?> n) {
						return n.verticalCellSpacing;
					}
				};

		CssMetaData<GridView<?,?>,Number> CELL_WIDTH =
				new CssMetaData<>("-fx-cell-width", StyleConverter.getSizeConverter(), 64d) {

					@Override
					public Double getInitialValue(GridView<?,?> node) {
						return node.cellWidth.getValue();
					}

					@Override
					public boolean isSettable(GridView<?,?> n) {
						return n.cellWidth==null || !n.cellWidth.isBound();
					}

					@Override
					public StyleableProperty<Number> getStyleableProperty(GridView<?,?> n) {
						return n.cellWidth;
					}
				};

		CssMetaData<GridView<?,?>,Number> CELL_HEIGHT =
				new CssMetaData<>("-fx-cell-height", StyleConverter.getSizeConverter(), 64d) {

					@Override
					public Double getInitialValue(GridView<?,?> node) {
						return node.cellHeight.getValue();
					}

					@Override
					public boolean isSettable(GridView<?,?> n) {
						return n.cellHeight==null || !n.cellHeight.isBound();
					}

					@Override
					public StyleableProperty<Number> getStyleableProperty(GridView<?,?> n) {
						return n.cellHeight;
					}
				};

		List<CssMetaData<? extends Styleable,?>> STYLEABLES = stream(
					stream(HORIZONTAL_CELL_SPACING, VERTICAL_CELL_SPACING, CELL_WIDTH, CELL_HEIGHT),
					stream(Control.getClassCssMetaData())
				)
				.collect(collectingAndThen(toList(), Collections::unmodifiableList));
	}

	/**
	 * @return The CssMetaData associated with this class, which may include the CssMetaData of its super classes.
	 */
	public static List<CssMetaData<? extends Styleable,?>> getClassCssMetaData() {
		return StyleableProperties.STYLEABLES;
	}

	@Override
	public List<CssMetaData<? extends Styleable,?>> getControlCssMetaData() {
		return getClassCssMetaData();
	}

	/** Strategy for cell selection behavior. */
	public enum SelectionOn {
		MOUSE_HOVER, MOUSE_CLICK, KEY_PRESS
	}

	/** Predefined cell sizes. */
	public enum CellSize {
		SMALL(80),
		NORMAL(160),
		LARGE(240),
		VERY_LARGE(400),
		GIANT(600),
		EXTREME(800);

		public final double width;

		CellSize(double width) {
			this.width = width;
		}
	}

	public enum CellGap {
		ABSOLUTE, RELATIVE
	}

	public class Search extends SearchAutoCancelable {

		// TODO: change type to ObjectField & implement exactly the same as in FilteredTable
		public StringGetter<F> field = (object,substitute) -> Objects.toString(object);

		private Search() {}

		@Override
		public void doSearch(String query) {
			for (int i = 0; i<getItemsShown().size(); i++) {
				T item = getItemsShown().get(i);
				String itemS = item==null ? null : field.getOfS(filterByMapper.apply(item), "");
				if (itemS!=null && isMatchNth(itemS, query)) {
					implGetSkin().select(i);
					updateSearchStyles();
					break;
				}
			}
		}

		@Override
		public void cancel() {
			super.cancel();
			getCellsAll().forEach(cell -> {
				cell.pseudoClassStateChanged(PC_SEARCH_MATCH, false);
				cell.pseudoClassStateChanged(PC_SEARCH_MATCH_NOT, false);
			});
		}

		void updateSearchStyles() {
			if (SearchAutoCancelable.Companion.isCancelable().getValue())
				searchAutoCanceller.start(SearchAutoCancelable.Companion.getCancelActivityDelay().getValue());
			updateSearchStyleRowsNoReset();
		}

		// TODO: move to skin
		void updateSearchStyleRowsNoReset() {
			boolean searchOn = isActive();
			getCellsShown().forEach(cell -> {
				T item = cell.getItem();
				String itemS = item==null ? null : field.getOfS(filterByMapper.apply(item), "");
				boolean isMatch = itemS!=null && isMatch(itemS, searchQuery.get());
				cell.pseudoClassStateChanged(PC_SEARCH_MATCH, searchOn && isMatch);
				cell.pseudoClassStateChanged(PC_SEARCH_MATCH_NOT, searchOn && !isMatch);
			});
		}
	}
}