/*
 * Loosely based on ControlsFX:
 *
 * Copyright (c) 2013, ControlsFX
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *     * Neither the name of ControlsFX, any associated website, nor the
 * names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL CONTROLSFX BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package sp.it.pl.gui.objects.grid;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Stream;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.collections.transformation.SortedList;
import javafx.css.CssMetaData;
import javafx.css.StyleConverter;
import javafx.css.Styleable;
import javafx.css.StyleableDoubleProperty;
import javafx.css.StyleableProperty;
import javafx.event.Event;
import javafx.scene.control.Control;
import javafx.util.Callback;
import org.reactfx.EventStreams;
import sp.it.pl.gui.objects.search.SearchAutoCancelable;
import sp.it.pl.util.access.V;
import sp.it.pl.util.access.fieldvalue.ObjectField;
import sp.it.pl.util.access.fieldvalue.StringGetter;
import sp.it.pl.util.functional.Functors.Ƒ1;
import static java.util.stream.Collectors.collectingAndThen;
import static java.util.stream.Collectors.toList;
import static javafx.collections.FXCollections.observableArrayList;
import static sp.it.pl.gui.objects.grid.GridView.SelectionOn.KEY_PRESS;
import static sp.it.pl.gui.objects.grid.GridView.SelectionOn.MOUSE_CLICK;
import static sp.it.pl.util.functional.Util.set;
import static sp.it.pl.util.functional.Util.stream;

/**
 * A GridView is an 2D virtualized control for displaying items in a 2D grid. It offers similar set of features as
 * {@link sp.it.pl.gui.objects.table.FilteredTable}, namely sorting, searching and filtering.
 * <p/>
 * This container is virtualized - the number of {@link sp.it.pl.gui.objects.grid.GridCell} instances depends on the number of
 * items displayed, not total. This helps to improve performance and reduce memory consumption.
 *
 * @param <T> type of item wrapper to hold cached attributes of the item, can be the item type itself
 * @param <F> type of item displayed in a grid
 * @see GridCell
 */
public class GridView<T, F> extends Control {

	final Class<F> type;
	final ObservableList<T> itemsAll;
	final FilteredList<T> itemsFiltered;
	final SortedList<T> itemsSorted;
	final Ƒ1<T,F> filterByMapper;

	/*
	 * Predicate that filters the table list. Null predicate will match all
	 * items (same as always true predicate). The value reflects the filter
	 * generated by the user through the {@link #searchBox}. Changing the
	 * predicate programmatically is possible, however the searchBox will not
	 * react on the change, its effect will merely be overridden and when
	 * search box predicate changes, it will in turn override effect of a
	 * custom predicate.
	 */
	public final ObjectProperty<Predicate<? super T>> itemsPredicate;
	public final ObjectProperty<Comparator<? super T>> itemsComparator;

	public final V<T> selectedItem = new V<>(null);

	public ObjectField<F,?> primaryFilterField;
	public final Search search = new Search();

	/** Creates a default, empty GridView control. */
	public GridView(Class<F> type) {
		this(type, null, null);
	}

	/** Creates a default, empty GridView control. */
	public GridView(Class<F> type, Ƒ1<T,F> filterByMapper) {
		this(type, filterByMapper, null);
	}

	/** Convenience constructor. Creates an empty GridView with specified sizes. */
	public GridView(Class<F> type, Ƒ1<T,F> filterByMapper, double cellWidth, double cellHeight, double vGap, double hGap) {
		this(type, filterByMapper, null);
		setCellWidth(cellWidth);
		setCellHeight(cellHeight);
		setHorizontalCellSpacing(hGap);
		setVerticalCellSpacing(vGap);
	}

	/** Convenience constructor. Creates a default GridView with the provided items. */
	@SuppressWarnings("unchecked")
	public GridView(Class<F> type, Ƒ1<T,F> filterByMapper, ObservableList<T> backingList) {
		this.type = type;
		this.filterByMapper = filterByMapper==null ? x -> (F) x : filterByMapper;

		itemsAll = backingList==null ? observableArrayList() : backingList;
		itemsFiltered = new FilteredList<>(itemsAll);
		itemsSorted = new SortedList<>(itemsFiltered);

		itemsPredicate = itemsFiltered.predicateProperty();
		itemsComparator = itemsSorted.comparatorProperty();


		// search
		search.installOn(this);
		addEventFilter(Event.ANY, e -> {
			if (search.isActive())
				search.updateSearchStyles();
		});
		EventStreams.changesOf(getItemsShown()).subscribe(c -> {
			if (search.isActive())
				search.updateSearchStyles();
		});
		setOnScroll(Event::consume);


		setSkin(createDefaultSkin());

		getStyleClass().add(STYLE_CLASS);
	}

	@Override
	protected GridViewSkin<T,F> createDefaultSkin() {
		return new GridViewSkin<>(this);
	}

	@SuppressWarnings("unchecked")
	public GridViewSkin<T,F> implGetSkin() {
		return (GridViewSkin) getSkin();
	}

	public ObservableList<T> getItemsRaw() {
		return itemsAll;
	}

	public ObservableList<T> getItemsShown() {
		return itemsSorted;
	}

	public Stream<GridCell<T,F>> getCellsShown() {
		return implGetSkin().getCells();
	}

	/**
	 * Contains {@link sp.it.pl.gui.objects.grid.GridView.SelectionOn} constants, signaling when should the selection change.
	 * By default, contains {@link SelectionOn#MOUSE_CLICK} and {@link SelectionOn#KEY_PRESS}.
	 * <p/>
	 * Removing all elements from this sets will cause this grid ignore selection
	 */
	public final Set<SelectionOn> selectOn = set(MOUSE_CLICK, KEY_PRESS);

	/**
	 * Returns selected items.
	 * <p/>
	 * The stream is intended for immediate consumption because it may be backed by an observable.
	 */
	public Stream<T> getSelectedItems() {
		return selectedItem.get()==null ? Stream.empty() : Stream.of(selectedItem.get());
	}

	/**
	 * Returns selected items or all if none selected.
	 */
	public Stream<T> getSelectedOrAllItems() {
		return selectedItem.get()==null ? getItemsShown().stream() : Stream.of(selectedItem.get());
	}

	/**
	 * Returns selected items or all if none selected and asked
	 * <p/>
	 * The stream is intended for immediate consumption because it may be backed by an observable.
	 *
	 * @param orAll whether all items should be returned when no item is selected
	 */
	public Stream<T> getSelectedOrAllItems(boolean orAll) {
		return orAll ? getSelectedOrAllItems() : getSelectedItems();
	}

	/**
	 * Property for specifying how much spacing there is between each cell
	 * in a row (i.e. how much horizontal spacing there is).
	 */
	public final DoubleProperty horizontalCellSpacingProperty() {
		if (horizontalCellSpacing==null) {
			horizontalCellSpacing = new StyleableDoubleProperty(12) {
				@Override
				public CssMetaData<GridView<?,?>,Number> getCssMetaData() {
					return GridView.StyleableProperties.HORIZONTAL_CELL_SPACING;
				}

				@Override
				public Object getBean() {
					return GridView.this;
				}

				@Override
				public String getName() {
					return "horizontalCellSpacing";
				}
			};
		}
		return horizontalCellSpacing;
	}

	private DoubleProperty horizontalCellSpacing;

	/**
	 * Sets the amount of horizontal spacing there should be between cells in
	 * the same row.
	 *
	 * @param value The amount of spacing to use.
	 */
	public final void setHorizontalCellSpacing(double value) {
		horizontalCellSpacingProperty().set(value);
	}

	/**
	 * Returns the amount of horizontal spacing there is between cells in
	 * the same row.
	 */
	public final double getHorizontalCellSpacing() {
		return horizontalCellSpacing==null ? 12.0 : horizontalCellSpacing.get();
	}

	/**
	 * Property for specifying how much spacing there is between each cell
	 * in a column (i.e. how much vertical spacing there is).
	 */
	private DoubleProperty verticalCellSpacing;

	public final DoubleProperty verticalCellSpacingProperty() {
		if (verticalCellSpacing==null) {
			verticalCellSpacing = new StyleableDoubleProperty(12) {
				@Override
				public CssMetaData<GridView<?,?>,Number> getCssMetaData() {
					return GridView.StyleableProperties.VERTICAL_CELL_SPACING;
				}

				@Override
				public Object getBean() {
					return GridView.this;
				}

				@Override
				public String getName() {
					return "verticalCellSpacing";
				}
			};
		}
		return verticalCellSpacing;
	}

	/**
	 * Sets the amount of vertical spacing there should be between cells in
	 * the same column.
	 *
	 * @param value The amount of spacing to use.
	 */
	public final void setVerticalCellSpacing(double value) {
		verticalCellSpacingProperty().set(value);
	}

	/**
	 * Returns the amount of vertical spacing there is between cells in
	 * the same column.
	 */
	public final double getVerticalCellSpacing() {
		return verticalCellSpacing==null ? 12.0 : verticalCellSpacing.get();
	}

	/**
	 * Property representing the width that all cells should be.
	 */
	public final DoubleProperty cellWidthProperty() {
		if (cellWidth==null) {
			cellWidth = new StyleableDoubleProperty(64) {
				@Override
				public CssMetaData<GridView<?,?>,Number> getCssMetaData() {
					return GridView.StyleableProperties.CELL_WIDTH;
				}

				@Override
				public Object getBean() {
					return GridView.this;
				}

				@Override
				public String getName() {
					return "cellWidth";
				}
			};
		}
		return cellWidth;
	}

	private DoubleProperty cellWidth;

	/**
	 * Sets the width that all cells should be.
	 */
	public final void setCellWidth(double value) {
		cellWidthProperty().set(value);
	}

	/**
	 * Returns the width that all cells should be.
	 */
	public final double getCellWidth() {
		return cellWidth==null ? 64.0 : cellWidth.get();
	}

	/**
	 * Property representing the height that all cells should be.
	 */
	public final DoubleProperty cellHeightProperty() {
		if (cellHeight==null) {
			cellHeight = new StyleableDoubleProperty(64) {
				@Override
				public CssMetaData<GridView<?,?>,Number> getCssMetaData() {
					return GridView.StyleableProperties.CELL_HEIGHT;
				}

				@Override
				public Object getBean() {
					return GridView.this;
				}

				@Override
				public String getName() {
					return "cellHeight";
				}
			};
		}
		return cellHeight;
	}

	private DoubleProperty cellHeight;

	/**
	 * Sets the height that all cells should be.
	 */
	public final void setCellHeight(double value) {
		cellHeightProperty().set(value);
	}

	/**
	 * Returns the height that all cells should be.
	 */
	public final double getCellHeight() {
		return cellHeight==null ? 64.0 : cellHeight.get();
	}

	public void setCellSize(double cellWidth, double cellHeight) {
		setCellWidth(cellWidth);
		setCellHeight(cellHeight);
	}

	private ObjectProperty<Callback<GridView<T,F>,GridCell<T,F>>> cellFactory = new SimpleObjectProperty<>(this, "cellFactory");

	/**
	 * Property representing the cell factory that is currently set in this
	 * GridView, or null if no cell factory has been set (in which case the
	 * default cell factory provided by the GridView skin will be used). The cell
	 * factory is used for instantiating enough GridCell instances for the
	 * visible area of the GridView. Refer to the GridView class documentation
	 * for more information and examples.
	 */
	public final ObjectProperty<Callback<GridView<T,F>,GridCell<T,F>>> cellFactoryProperty() {
		return cellFactory;
	}

	/**
	 * Sets the cell factory to use to create {@link GridCell} instances to
	 * show in the GridView.
	 */
	public final void setCellFactory(Callback<GridView<T,F>,GridCell<T,F>> value) {
		cellFactory.set(value);
	}

	/**
	 * Returns the cell factory that will be used to create {@link GridCell}
	 * instances to show in the GridView.
	 */
	public final Callback<GridView<T,F>,GridCell<T,F>> getCellFactory() {
		return cellFactory.get();
	}

	public static final String STYLE_CLASS = "grid-view";

	private interface StyleableProperties {
		CssMetaData<GridView<?,?>,Number> HORIZONTAL_CELL_SPACING =
				new CssMetaData<>("-fx-horizontal-cell-spacing", StyleConverter.getSizeConverter(), 12d) {

					@Override
					public Double getInitialValue(GridView<?,?> node) {
						return node.getHorizontalCellSpacing();
					}

					@Override
					public boolean isSettable(GridView<?,?> n) {
						return n.horizontalCellSpacing==null || !n.horizontalCellSpacing.isBound();
					}

					@Override
					@SuppressWarnings("unchecked")
					public StyleableProperty<Number> getStyleableProperty(GridView<?,?> n) {
						return (StyleableProperty<Number>) n.horizontalCellSpacingProperty();
					}
				};

		CssMetaData<GridView<?,?>,Number> VERTICAL_CELL_SPACING =
				new CssMetaData<>("-fx-vertical-cell-spacing", StyleConverter.getSizeConverter(), 12d) {

					@Override
					public Double getInitialValue(GridView<?,?> node) {
						return node.getVerticalCellSpacing();
					}

					@Override
					public boolean isSettable(GridView<?,?> n) {
						return n.verticalCellSpacing==null || !n.verticalCellSpacing.isBound();
					}

					@Override
					@SuppressWarnings("unchecked")
					public StyleableProperty<Number> getStyleableProperty(GridView<?,?> n) {
						return (StyleableProperty<Number>) n.verticalCellSpacingProperty();
					}
				};

		CssMetaData<GridView<?,?>,Number> CELL_WIDTH =
				new CssMetaData<>("-fx-cell-width", StyleConverter.getSizeConverter(), 64d) {

					@Override
					public Double getInitialValue(GridView<?,?> node) {
						return node.getCellWidth();
					}

					@Override
					public boolean isSettable(GridView<?,?> n) {
						return n.cellWidth==null || !n.cellWidth.isBound();
					}

					@Override
					@SuppressWarnings("unchecked")
					public StyleableProperty<Number> getStyleableProperty(GridView<?,?> n) {
						return (StyleableProperty<Number>) n.cellWidthProperty();
					}
				};

		CssMetaData<GridView<?,?>,Number> CELL_HEIGHT =
				new CssMetaData<>("-fx-cell-height", StyleConverter.getSizeConverter(), 64d) {

					@Override
					public Double getInitialValue(GridView<?,?> node) {
						return node.getCellHeight();
					}

					@Override
					public boolean isSettable(GridView<?,?> n) {
						return n.cellHeight==null || !n.cellHeight.isBound();
					}

					@Override
					@SuppressWarnings("unchecked")
					public StyleableProperty<Number> getStyleableProperty(GridView<?,?> n) {
						return (StyleableProperty<Number>) n.cellHeightProperty();
					}
				};

		List<CssMetaData<? extends Styleable,?>> STYLEABLES = stream(
					stream(HORIZONTAL_CELL_SPACING, VERTICAL_CELL_SPACING, CELL_WIDTH, CELL_HEIGHT),
					stream(Control.getClassCssMetaData())
				)
				.collect(collectingAndThen(toList(), Collections::unmodifiableList));
	}

	/**
	 * @return The CssMetaData associated with this class, which may include the CssMetaData of its super classes.
	 */
	public static List<CssMetaData<? extends Styleable,?>> getClassCssMetaData() {
		return StyleableProperties.STYLEABLES;
	}

	@Override
	public List<CssMetaData<? extends Styleable,?>> getControlCssMetaData() {
		return getClassCssMetaData();
	}

	/** Strategy for cell selection behavior. */
	public enum SelectionOn {
		MOUSE_HOVER, MOUSE_CLICK, KEY_PRESS
	}

	/** Predefined cell sizes. */
	public enum CellSize {
		SMALL(80),
		NORMAL(160),
		LARGE(240),
		VERY_LARGE(400),
		GIANT(600),
		EXTREME(800);

		public final double width;

		CellSize(double width) {
			this.width = width;
		}
	}

	public class Search extends SearchAutoCancelable {

		// TODO: change type to ObjectField & implement exactly the same as in FilteredTable
		public StringGetter<F> field = (object,substitute) -> Objects.toString(object);

		private Search() {}

		@Override
		public void doSearch(String query) {
			for (int i = 0; i<getItemsShown().size(); i++) {
				T item = getItemsShown().get(i);
				String itemS = item==null ? null : field.getOfS(filterByMapper.apply(item), "");
				if (itemS!=null && isMatchNth(itemS, query)) {
					implGetSkin().select(i);
					updateSearchStyles();
					break;
				}
			}
		}

		@Override
		public void cancel() {
			super.cancel();
			updateSearchStyleRowsNoReset();
		}

		void updateSearchStyles() {
			if (SearchAutoCancelable.Companion.isCancelable()) searchAutoCanceller.start(SearchAutoCancelable.Companion.getCancelActivityDelay());
			updateSearchStyleRowsNoReset();
		}

		// TODO: move to skin
		void updateSearchStyleRowsNoReset() {
			boolean searchOn = isActive();
			getCellsShown().forEach(cell -> {
				T item = cell.getItem();
				String itemS = item==null ? null : field.getOfS(filterByMapper.apply(item), "");
				boolean isMatch = itemS!=null && isMatch(itemS, searchQuery.get());
				cell.pseudoClassStateChanged(PC_SEARCH_MATCH, searchOn && isMatch);
				cell.pseudoClassStateChanged(PC_SEARCH_MATCH_NOT, searchOn && !isMatch);
			});
		}
	}
}